""Agent per a la generació de portades de llibres minimalistes i simbòliques."""

import io
import json
from pathlib import Path
from typing import Literal

from PIL import Image, ImageDraw, ImageFont
from pydantic import BaseModel, Field

from agents.base_agent import AgentConfig, AgentResponse, BaseAgent
from agents.venice_client import VeniceClient, VeniceError


# Tipus de gènere literari
GenreLiterari = Literal["FIL", "POE", "TEA", "NOV", "SAG", "ORI", "EPO"]


class PaletaGenere(BaseModel):
    """Paleta de colors i estil per a un gènere literari."""

    colors: list[str]
    estil: str
    descripcio: str
    background: str  # Color de fons dominant
    accent: str      # Color d'accent principal


# Paletes de colors per gènere
PALETES: dict[str, PaletaGenere] = {
    "FIL": PaletaGenere(
        colors=["blanc", "gris", "negre", "or"],
        estil="geomètric, filosòfic, abstracte",
        descripcio="Formes geomètriques pures, línies netes, espai contemplatiu",
        background="#F5F5F5",
        accent="#1A1A1A",
    ),
    "POE": PaletaGenere(
        colors=["pastels suaus", "rosa pàl·lid", "blau cel", "accent intens"],
        estil="líric, eteri, delicat",
        descripcio="Atmosfera onírica, formes fluides, llum suau difusa",
        background="#F8F4F9",
        accent="#8B4B6E",
    ),
    "TEA": PaletaGenere(
        colors=["negre profund", "vermell intens", "or"],
        estil="dramàtic, alt contrast, teatral",
        descripcio="Clarobscur intens, màscares, cortines, escenari",
        background="#1A1A1A",
        accent="#C41E3A",
    ),
    "NOV": PaletaGenere(
        colors=["tons atmosfèrics", "sèpia", "blau grisós"],
        estil="narratiu, atmosfèric, evocador",
        descripcio="Paisatges difuminats, siluetes, profunditat atmosfèrica",
        background="#E8E4DF",
        accent="#4A5568",
    ),
    "SAG": PaletaGenere(
        colors=["blau profund", "or", "blanc lluminós"],
        estil="místic, lluminós, transcendent",
        descripcio="Llum celestial, símbols sagrats, aura mística",
        background="#0A1628",
        accent="#D4AF37",
    ),
    "ORI": PaletaGenere(
        colors=["tinta negra", "vermell xinès", "or", "blanc pergamí"],
        estil="cal·ligràfic, zen, minimalista oriental",
        descripcio="Pinzellada única, espai buit significatiu, equilibri asimètric",
        background="#FAF8F5",
        accent="#B22222",
    ),
    "EPO": PaletaGenere(
        colors=["tons terra", "bronze", "cel blau profund", "or antic"],
        estil="heroic, monumental, antic",
        descripcio="Figures heroiques, arquitectura monumental, llum daurada",
        background="#2C1810",
        accent="#CD7F32",
    ),
}


class PromptResult(BaseModel):
    """Resultat de la generació de prompt."""

    prompt: str
    negative_prompt: str
    simbol: str
    raonament: str
    paleta: str
    genere: str


class PortadistaConfig(BaseModel):
    """Configuració de l'agent portadista."""

    width: int = Field(default=832, ge=512, le=1280)   # Venice limit: 1280
    height: int = Field(default=1216, ge=512, le=1280)  # Ratio ~2:3 vertical
    model_imatge: str = "flux-2-max"
    steps: int = Field(default=30, ge=15, le=50)
    font_titol: str = "DejaVuSerif-Bold"
    font_autor: str = "DejaVuSerif"
    font_editorial: str = "DejaVuSans"


class AgentPortadista(BaseAgent):
    """Agent especialitzat en generar portades de llibres minimalistes.

    Utilitza Claude per crear prompts artístics basats en les metadades
    de l'obra, i Venice.ai per generar les imatges.

    Estil visual:
    - MINIMALISTA i SIMBÒLIC
    - Un sol element visual central
    - Mai text a la imatge (s'afegeix després)
    - Molt espai negatiu

    Exemple d'ús:
        ```python
        agent = AgentPortadista()

        metadata = {
            "titol": "L'Epopeia de Gilgamesh",
            "autor": "Anònim mesopotàmic",
            "genere": "EPO",
            "temes": ["heroisme", "amistat", "mortalitat"],
            "descripcio": "L'epopeia més antiga...",
        }

        # Generar prompt
        prompt_result = agent.crear_prompt(metadata)
        print(f"Símbol: {prompt_result['simbol']}")
        print(f"Prompt: {prompt_result['prompt']}")

        # Generar portada completa
        imatge_bytes = agent.generar_portada(metadata)
        Path("portada.png").write_bytes(imatge_bytes)
        ```
    """

    agent_name = "Portadista"

    # Logo del dofí Arion (SVG path simplificat o es carrega extern)
    LOGO_ARION_PATH = Path(__file__).parent.parent / "assets" / "arion_logo.png"

    def __init__(
        self,
        config: AgentConfig | None = None,
        portadista_config: PortadistaConfig | None = None,
        venice_client: VeniceClient | None = None,
    ) -> None:
        """Inicialitza l'agent portadista.

        Args:
            config: Configuració de l'agent Claude.
            portadista_config: Configuració específica del portadista.
            venice_client: Client Venice.ai (es crea automàticament si no es proporciona).
        """
        super().__init__(config)
        self.portadista_config = portadista_config or PortadistaConfig()

        # Inicialitzar Venice client (pot fallar si no hi ha API key)
        try:
            self.venice = venice_client or VeniceClient()
        except VeniceError as e:
            self.log_warning(f"Venice client no disponible: {e}")
            self.venice = None

    @property
    def system_prompt(self) -> str:
        """System prompt per a la generació de prompts artístics."""
        return """Ets un director artístic expert en disseny de portades de llibres MINIMALISTES i SIMBÒLIQUES per a una editorial de clàssics.

FILOSOFIA DE DISSENY:
- UN SOL element visual central que capturi l'ESSÈNCIA de l'obra
- MAI text dins la imatge (s'afegeix després digitalment)
- Espai negatiu abundant (60-70% de la composició)
- Símbols universals i atemporals
- Elegància a través de la simplicitat

PALETES DE COLORS PER GÈNERE:
- FIL (Filosofia): blanc/gris/negre/or - geomètric, abstracte
- POE (Poesia): pastels suaus amb accent intens - líric, eteri
- TEA (Teatre): negre/vermell/or - dramàtic, alt contrast
- NOV (Novel·la): tons atmosfèrics - narratiu, evocador
- SAG (Sagrat): blau profund/or/blanc - místic, lluminós
- ORI (Oriental): tinta negra/vermell/or - cal·ligràfic, zen
- EPO (Epopeia): tons terra/bronze/cel - heroic, monumental

RESPOSTA EN FORMAT JSON:
{
    "simbol": "Descripció breu del símbol central escollit",
    "raonament": "Per què aquest símbol representa l'essència de l'obra",
    "prompt": "Prompt complet per a generació d'imatge (en anglès, molt detallat)",
    "negative_prompt": "Elements a evitar (en anglès)"
}

REGLES PER AL PROMPT:
1. Sempre en anglès
2. Començar amb l'estil: "Minimalist book cover illustration, single symbolic element..."
3. Especificar colors de la paleta del gènere
4. Incloure: "vast negative space, clean composition, no text, no letters, no title"
5. Afegir qualitat: "editorial quality, sophisticated, timeless design"
6. El símbol ha de ser SIMPLE però EVOCADOR"""

    def _detectar_genere(self, metadata: dict) -> GenreLiterari:
        """Detecta el gènere literari a partir de les metadades.

        Args:
            metadata: Diccionari amb metadades de l'obra.

        Returns:
            Codi de gènere (FIL, POE, TEA, NOV, SAG, ORI, EPO).
        """
        # Si ja ve especificat
        if "genere" in metadata:
            genere = metadata["genere"].upper()
            if genere in PALETES:
                return genere

        # Detectar per temes o descripció
        temes = metadata.get("temes", [])
        descripcio = metadata.get("descripcio", "").lower()
        titol = metadata.get("titol", "").lower()

        temes_lower = [t.lower() for t in temes]

        # Heurístiques simples
        if any(t in temes_lower for t in ["filosofia", "ètica", "metafísica", "lògica"]):
            return "FIL"
        if any(t in temes_lower for t in ["poesia", "lírica", "vers", "oda"]):
            return "POE"
        if any(t in temes_lower for t in ["teatre", "drama", "tragèdia", "comèdia"]):
            return "TEA"
        if any(t in temes_lower for t in ["sagrat", "religiós", "mística", "espiritual", "bíblia"]):
            return "SAG"
        if any(t in temes_lower for t in ["oriental", "zen", "tao", "confuci", "xinès", "japonès"]):
            return "ORI"
        if any(t in temes_lower for t in ["epopeia", "heroisme", "mite", "llegenda", "heroi"]):
            return "EPO"

        # Detectar per paraules clau a la descripció
        if "epopeia" in descripcio or "heroi" in descripcio or "èpic" in descripcio:
            return "EPO"
        if "filosofia" in descripcio or "diàleg" in descripcio:
            return "FIL"
        if "poema" in descripcio or "vers" in descripcio:
            return "POE"

        # Per defecte, novel·la
        return "NOV"

    def crear_prompt(self, metadata: dict) -> dict:
        """Genera un prompt artístic basat en les metadades de l'obra.

        Args:
            metadata: Diccionari amb:
                - titol: Títol de l'obra
                - autor: Autor
                - genere (opcional): FIL, POE, TEA, NOV, SAG, ORI, EPO
                - temes (opcional): Llista de temes
                - descripcio (opcional): Descripció de l'obra

        Returns:
            dict amb prompt, negative_prompt, simbol, raonament, paleta, genere
        """
        genere = self._detectar_genere(metadata)
        paleta = PALETES[genere]

        # Construir petició per a Claude
        request_text = f"""Genera un prompt per a la portada d'aquest llibre:

TÍTOL: {metadata.get('titol', 'Sense títol')}
AUTOR: {metadata.get('autor', 'Anònim')}
GÈNERE: {genere} ({paleta.descripcio})
COLORS: {', '.join(paleta.colors)}
ESTIL: {paleta.estil}

TEMES: {', '.join(metadata.get('temes', ['general']))}

DESCRIPCIÓ: {metadata.get('descripcio', 'No disponible')}

Recorda:
- UN SOL símbol central
- Molt espai negatiu
- Colors de la paleta {genere}
- Prompt en anglès
- Mai text a la imatge"""

        # Obtenir resposta de Claude
        response = self.process(request_text)

        # Parsejar JSON de la resposta
        try:
            # Buscar JSON a la resposta
            content = response.content
            json_start = content.find("{")
            json_end = content.rfind("}") + 1

            if json_start >= 0 and json_end > json_start:
                json_str = content[json_start:json_end]
                data = json.loads(json_str)
            else:
                raise ValueError("No s'ha trobat JSON a la resposta")

            return {
                "prompt": data.get("prompt", ""),
                "negative_prompt": data.get("negative_prompt", "text, letters, title, words, watermark"),
                "simbol": data.get("simbol", ""),
                "raonament": data.get("raonament", ""),
                "paleta": paleta.model_dump(),
                "genere": genere,
            }

        except (json.JSONDecodeError, ValueError) as e:
            self.log_warning(f"Error parsejant resposta: {e}")
            # Fallback: generar prompt bàsic
            return self._generar_prompt_fallback(metadata, genere, paleta)

    def _generar_prompt_fallback(
        self,
        metadata: dict,
        genere: str,
        paleta: PaletaGenere,
    ) -> dict:
        """Genera un prompt de fallback si Claude falla."""
        titol = metadata.get("titol", "")
        colors_str = ", ".join(paleta.colors)

        prompt = (
            f"Minimalist book cover illustration, single symbolic element, "
            f"{paleta.estil} style, {colors_str} color palette, "
            f"vast negative space, clean composition, no text, no letters, no title, "
            f"editorial quality, sophisticated, timeless design, "
            f"inspired by '{titol}'"
        )

        return {
            "prompt": prompt,
            "negative_prompt": "text, letters, title, words, watermark, busy, cluttered, multiple elements",
            "simbol": "Element simbòlic abstracte",
            "raonament": "Prompt generat automàticament",
            "paleta": paleta.model_dump(),
            "genere": genere,
        }

    def generar_portada(
        self,
        metadata: dict,
        afegir_text: bool = True,
        editorial: str = "Biblioteca Arion",
    ) -> bytes:
        """Genera una portada completa per a un llibre.

        Args:
            metadata: Metadades de l'obra (titol, autor, genere, temes, descripcio).
            afegir_text: Si True, afegeix títol, autor i editorial a la imatge.
            editorial: Nom de l'editorial.

        Returns:
            bytes: Imatge PNG de la portada.

        Raises:
            VeniceError: Si la generació d'imatge falla.
            RuntimeError: Si Venice client no està disponible.
        """
        if not self.venice:
            raise RuntimeError(
                "Venice client no disponible. "
                "Comprova que VENICE_API_KEY està configurada a .env"
            )

        # 1. Generar prompt
        self.log_info("Generant prompt artístic...")
        prompt_result = self.crear_prompt(metadata)
        self.log_info(f"Símbol escollit: {prompt_result['simbol']}")

        # 2. Generar imatge amb Venice
        self.log_info("Generant imatge amb Venice.ai...")
        image_bytes = self.venice.generar_imatge_sync(
            prompt=prompt_result["prompt"],
            negative_prompt=prompt_result["negative_prompt"],
            width=self.portadista_config.width,
            height=self.portadista_config.height,
            model=self.portadista_config.model_imatge,
            steps=self.portadista_config.steps,
        )

        # 3. Afegir text si cal
        if afegir_text:
            self.log_info("Afegint text a la portada...")
            image_bytes = self.afegir_text_portada(
                imatge=image_bytes,
                titol=metadata.get("titol", ""),
                autor=metadata.get("autor", ""),
                editorial=editorial,
                genere=prompt_result["genere"],
            )

        self.log_info("Portada generada correctament")
        return image_bytes

    def afegir_text_portada(
        self,
        imatge: bytes,
        titol: str,
        autor: str,
        editorial: str = "Biblioteca Arion",
        genere: str = "NOV",
    ) -> bytes:
        """Afegeix text (títol, autor, editorial) a una imatge de portada.

        Args:
            imatge: Imatge PNG en bytes.
            titol: Títol del llibre.
            autor: Nom de l'autor.
            editorial: Nom de l'editorial.
            genere: Gènere per determinar colors del text.

        Returns:
            bytes: Imatge PNG amb text afegit.
        """
        # Obrir imatge
        img = Image.open(io.BytesIO(imatge))
        draw = ImageDraw.Draw(img)

        width, height = img.size
        paleta = PALETES.get(genere, PALETES["NOV"])

        # Determinar color del text segons el fons
        # Si el fons és fosc, text clar; si és clar, text fosc
        bg_hex = paleta.background.lstrip("#")
        bg_rgb = tuple(int(bg_hex[i:i+2], 16) for i in (0, 2, 4))
        bg_luminance = (0.299 * bg_rgb[0] + 0.587 * bg_rgb[1] + 0.114 * bg_rgb[2]) / 255

        if bg_luminance < 0.5:
            # Fons fosc -> text clar
            color_titol = "#FFFFFF"
            color_autor = "#E0E0E0"
            color_editorial = "#A0A0A0"
        else:
            # Fons clar -> text fosc
            color_titol = "#1A1A1A"
            color_autor = "#3A3A3A"
            color_editorial = "#5A5A5A"

        # Carregar fonts (amb fallback a default)
        try:
            font_titol = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSerif-Bold.ttf", size=int(width * 0.06))
            font_autor = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSerif.ttf", size=int(width * 0.035))
            font_editorial = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf", size=int(width * 0.025))
        except OSError:
            # Fallback a font per defecte
            try:
                font_titol = ImageFont.truetype("/usr/share/fonts/truetype/liberation/LiberationSerif-Bold.ttf", size=int(width * 0.06))
                font_autor = ImageFont.truetype("/usr/share/fonts/truetype/liberation/LiberationSerif-Regular.ttf", size=int(width * 0.035))
                font_editorial = ImageFont.truetype("/usr/share/fonts/truetype/liberation/LiberationSans-Regular.ttf", size=int(width * 0.025))
            except OSError:
                font_titol = ImageFont.load_default()
                font_autor = ImageFont.load_default()
                font_editorial = ImageFont.load_default()

        # Posicions
        margin = int(width * 0.08)
        titol_y = int(height * 0.08)
        autor_y = int(height * 0.88)
        editorial_y = int(height * 0.94)

        # Dibuixar títol (centrat a dalt)
        if titol:
            titol_upper = titol.upper()
            bbox = draw.textbbox((0, 0), titol_upper, font=font_titol)
            titol_width = bbox[2] - bbox[0]

            # Si el títol és massa llarg, dividir en línies
            if titol_width > width - 2 * margin:
                lines = self._dividir_text(titol_upper, font_titol, width - 2 * margin, draw)
                current_y = titol_y
                for line in lines:
                    bbox = draw.textbbox((0, 0), line, font=font_titol)
                    line_width = bbox[2] - bbox[0]
                    x = (width - line_width) // 2
                    draw.text((x, current_y), line, fill=color_titol, font=font_titol)
                    current_y += int(font_titol.size * 1.3)
            else:
                x = (width - titol_width) // 2
                draw.text((x, titol_y), titol_upper, fill=color_titol, font=font_titol)

        # Dibuixar autor (centrat a baix)
        if autor:
            bbox = draw.textbbox((0, 0), autor, font=font_autor)
            autor_width = bbox[2] - bbox[0]
            x = (width - autor_width) // 2
            draw.text((x, autor_y), autor, fill=color_autor, font=font_autor)

        # Dibuixar editorial (centrat al fons)
        if editorial:
            bbox = draw.textbbox((0, 0), editorial, font=font_editorial)
            editorial_width = bbox[2] - bbox[0]
            x = (width - editorial_width) // 2
            draw.text((x, editorial_y), editorial, fill=color_editorial, font=font_editorial)

        # Afegir logo Arion si existeix
        self._afegir_logo(img, genere)

        # Guardar a bytes
        output = io.BytesIO()
        img.save(output, format="PNG", quality=95)
        return output.getvalue()

    def _dividir_text(
        self,
        text: str,
        font: ImageFont.FreeTypeFont,
        max_width: int,
        draw: ImageDraw.ImageDraw,
    ) -> list[str]:
        """Divideix text en línies que càpiguen dins l'amplada màxima."""
        words = text.split()
        lines = []
        current_line = []

        for word in words:
            test_line = " ".join(current_line + [word])
            bbox = draw.textbbox((0, 0), test_line, font=font)
            if bbox[2] - bbox[0] <= max_width:
                current_line.append(word)
            else:
                if current_line:
                    lines.append(" ".join(current_line))
                current_line = [word]

        if current_line:
            lines.append(" ".join(current_line))

        return lines

    def _afegir_logo(self, img: Image.Image, genere: str) -> None:
        """Afegeix el logo del dofí Arion a la part inferior de la imatge.

        El logo es mostra modest i semi-transparent.
        """
        if not self.LOGO_ARION_PATH.exists():
            # Si no hi ha logo, dibuixar un símbol simple
            self._dibuixar_logo_simple(img, genere)
            return

        try:
            logo = Image.open(self.LOGO_ARION_PATH).convert("RGBA")

            # Redimensionar logo (5% de l'amplada)
            logo_width = int(img.width * 0.05)
            ratio = logo_width / logo.width
            logo_height = int(logo.height * ratio)
            logo = logo.resize((logo_width, logo_height), Image.Resampling.LANCZOS)

            # Aplicar transparència
            alpha = logo.split()[3]
            alpha = alpha.point(lambda p: int(p * 0.5))  # 50% transparent
            logo.putalpha(alpha)

            # Posició: centrat a baix
            x = (img.width - logo_width) // 2
            y = img.height - logo_height - int(img.height * 0.02)

            img.paste(logo, (x, y), logo)

        except Exception as e:
            self.log_warning(f"No s'ha pogut afegir el logo: {e}")

    def _dibuixar_logo_simple(self, img: Image.Image, genere: str) -> None:
        """Dibuixa un logo simple (ona estilitzada) si no hi ha fitxer de logo."""
        draw = ImageDraw.Draw(img)

        # Determinar color segons paleta
        paleta = PALETES.get(genere, PALETES["NOV"])
        bg_hex = paleta.background.lstrip("#")
        bg_rgb = tuple(int(bg_hex[i:i+2], 16) for i in (0, 2, 4))
        bg_luminance = (0.299 * bg_rgb[0] + 0.587 * bg_rgb[1] + 0.114 * bg_rgb[2]) / 255

        # Color del logo amb transparència
        if bg_luminance < 0.5:
            color = (255, 255, 255, 80)  # Blanc semi-transparent
        else:
            color = (0, 0, 0, 80)  # Negre semi-transparent

        # Dibuixar una petita ona estilitzada (símbol d'Arion, el dofí)
        center_x = img.width // 2
        y = img.height - int(img.height * 0.035)
        size = int(img.width * 0.03)

        # Ona simple amb tres arcs
        points = [
            (center_x - size, y),
            (center_x - size//2, y - size//3),
            (center_x, y),
            (center_x + size//2, y - size//3),
            (center_x + size, y),
        ]

        # Crear una imatge temporal amb alpha per la transparència
        overlay = Image.new("RGBA", img.size, (0, 0, 0, 0))
        overlay_draw = ImageDraw.Draw(overlay)
        overlay_draw.line(points, fill=color, width=2)

        # Composar
        img.paste(Image.alpha_composite(img.convert("RGBA"), overlay).convert("RGB"))


def generar_portada_obra(
    metadata_path: str | Path,
    output_path: str | Path | None = None,
    editorial: str = "Biblioteca Arion",
) -> Path:
    """Funció d'ajuda per generar la portada d'una obra des del seu metadata.yml.

    Args:
        metadata_path: Ruta al fitxer metadata.yml de l'obra.
        output_path: Ruta de sortida (per defecte: mateix directori, portada.png).
        editorial: Nom de l'editorial.

    Returns:
        Path al fitxer de portada generat.

    Exemple:
        ```python
        portada = generar_portada_obra("obres/mesopotamia/gilgamesh/metadata.yml")
        print(f"Portada generada: {portada}")
        ```
    """
    import yaml

    metadata_path = Path(metadata_path)

    # Llegir metadata
    with open(metadata_path) as f:
        data = yaml.safe_load(f)

    # Extreure dades de l'obra
    obra = data.get("obra", data)
    metadata = {
        "titol": obra.get("titol", ""),
        "autor": obra.get("autor", ""),
        "genere": obra.get("genere", ""),
        "temes": obra.get("temes", []),
        "descripcio": obra.get("descripcio", ""),
    }

    # Determinar ruta de sortida
    if output_path is None:
        output_path = metadata_path.parent / "portada.png"
    else:
        output_path = Path(output_path)

    # Generar portada
    agent = AgentPortadista()
    portada_bytes = agent.generar_portada(metadata, editorial=editorial)

    # Guardar
    output_path.write_bytes(portada_bytes)

    return output_path


if __name__ == "__main__":
    import sys

    print("Test de l'Agent Portadista")
    print("=" * 50)

    # Metadades d'exemple (Gilgamesh)
    metadata_gilgamesh = {
        "titol": "L'Epopeia de Gilgamesh",
        "autor": "Anònim mesopotàmic",
        "genere": "EPO",
        "temes": ["heroisme", "amistat", "mortalitat", "cerca de la immortalitat"],
        "descripcio": "L'epopeia més antiga coneguda de la humanitat. Narra les aventures del rei Gilgamesh d'Uruk.",
    }

    agent = AgentPortadista()

    # Test 1: Crear prompt
    print("\n1. Generant prompt artístic...")
    try:
        prompt_result = agent.crear_prompt(metadata_gilgamesh)
        print(f"   Gènere detectat: {prompt_result['genere']}")
        print(f"   Símbol: {prompt_result['simbol']}")
        print(f"   Raonament: {prompt_result['raonament'][:100]}...")
        print(f"   Prompt: {prompt_result['prompt'][:150]}...")
    except Exception as e:
        print(f"   Error: {e}")

    # Test 2: Generar portada (si s'especifica --generate)
    if len(sys.argv) > 1 and sys.argv[1] == "--generate":
        print("\n2. Generant portada completa...")
        try:
            portada_bytes = agent.generar_portada(metadata_gilgamesh)
            output_path = Path("portada_gilgamesh_test.png")
            output_path.write_bytes(portada_bytes)
            print(f"   ✅ Portada guardada a {output_path}")
        except Exception as e:
            print(f"   ❌ Error: {e}")
    else:
        print("\n2. Per generar la portada completa, executa:")
        print("   python agents/portadista.py --generate")
